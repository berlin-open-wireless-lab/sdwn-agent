#ifndef UBUS_H
#define UBUS_H

#include <inttypes.h>
#include <netinet/ether.h>

#include "wlanflow.h"

/* Timeout of deferred ubus notifications by hostapd.
 * hostapd expects a reply within 100ms.
 */
#define DEFERRED_REQUEST_TIMEOUT_MS 100


int ubus_run_for_all_clients(uint32_t if_no, for_all_clients_cb fn,
						     void* params);

int ubus_add_client(uint32_t if_no, union station_info *sta,
				    bool encrypted);

int ubus_del_client(uint32_t if_no, struct ether_addr *client_mac,
				    uint16_t reason, bool deauth, uint32_t ban_time);

int ubus_set_channel(uint32_t if_no, uint32_t freq, uint32_t bcn_count);

int ubus_get_client_info(uint32_t if_no, struct ether_addr *client_mac,
					     const char *if_name, union station_info *client);


int ubus_get_wireless_info(struct wdev_info **devs, size_t *n_devs);

// FIXME: this needs refactoring. Holding all that control channel-related state
//        should not be done by the ubus module.
/* Begin monitoring hostapd.<ifname>.
 * This will create and maintain some state related to the interface such as
 * the connection ID for the controller that manages it, the control channel's
 * OpenFlow protocol version and ongoing transactions related to the interface.
 */
int ubus_mon_init(char *ifname, uint32_t port_no, struct ether_addr *bssid,
				  uint32_t channel, int cxn_id, int of_version, bool encrypted);

void ubus_mon_stop(int cxn_id);

/* query ovsd for datapath ID of given bridge */
int ubus_get_ovs_datapath_id(char *bridge, uint64_t *dpid);

/* Initialize ubus connection and register ubus fd with event loop. */
int ubus_init(const char *ubus_path);

void ubus_stop(void);

/* Called when a controller message has arrived instructing the switch to
 * respond either positively to an 802.11 management event generated by hostapd
 * or negatively. 
 * For example: When the switch overhears a probe request, hostapd notifies
 * us and the switch forwards the event to the controller. The controller then
 * makes the decision to either respond with a probe response or not to react at
 * all.
 * The events are stored for DEFERRED_REQUEST_TIMEOUT_MS ms and are keyed by
 * the interface and XID.
 */
void ubus_event_respond(uint32_t if_no, uint32_t xid, bool deny);

/* Look up context for the ubus monitoring by interface name or BSSID.
 * If if_name is given, the look up will be done by name, if if_name is NULL
 * bssid will be used. if_name takes precedence.
 */
int ubus_get_ctx_for_if(const char *if_name, uint32_t if_no, uint32_t *chan,
						int *cxn_id, int *of_version, bool *encrypted);

int ubus_get_release_desc(char *buf);

#endif /* UBUS_H */

